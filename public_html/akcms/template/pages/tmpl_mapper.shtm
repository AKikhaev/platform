<script>
    function makeXPath (node, currentPath) {
        /* this should suffice in HTML documents for selectable nodes, XML with namespaces needs more code */
        currentPath = currentPath || '';
        switch (node.nodeType) {
            case 3:
            case 4:
                return makeXPath(node.parentNode, 'text()[' + (document.evaluate('preceding-sibling::text()', node, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null).snapshotLength + 1) + ']');
            case 1:
                return makeXPath(node.parentNode, node.nodeName + '[' + (document.evaluate('preceding-sibling::' + node.nodeName, node, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null).snapshotLength + 1) + ']' + (currentPath ? '/' + currentPath : ''));
            case 9:
                return '/' + currentPath;
            default:
                return '';
        }
    }

    var _getSelected = function () {
//			try
        {
            //https://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text
            var w = window,d = w.document,_txt = null,_sel = null,_6=60,locate='';
            if (w.getSelection) {
                _sel = w.getSelection();
            } else if (d.getSelection) {
                _sel = d.getSelection();
            }
            if (_sel != null) {
                var pre = "", _txt = null, suf = "", pos = -1,f = null;
                if (_sel.getRangeAt) {
                    var r = _sel.getRangeAt(0);
                    //locate = r.commonAncestorContainer.innerHTML;
                    //r.setStartBefore(r.startContainer);
                    //r.setEndAfter(r.endContainer);
                    var findStart = r.startContainer,findEnd = r.endContainer;
                    //console.log(r.commonAncestorContainer,r.startContainer,r.endContainer);
                    if (r.commonAncestorContainer==r.startContainer || r.commonAncestorContainer==r.startContainer.parentNode) {} else {
                        while(findStart.parentNode!=r.commonAncestorContainer && findStart!=r.commonAncestorContainer) findStart=findStart.parentNode;
                        r.setStartBefore(findStart);
                    }
                    if (r.commonAncestorContainer==r.endContainer || r.commonAncestorContainer==r.endContainer.parentNode) {} else {
                        while(findEnd.parentNode!=r.commonAncestorContainer && findEnd!=r.commonAncestorContainer) findEnd=findEnd.parentNode;
                        r.setEndAfter(findEnd);
                    }
                    _txt = r.toString();
                    var div = document.createElement('div');
                    div.appendChild( r.cloneContents().cloneNode(true) ); //
                    _txt = {
                        'text':_txt,
                        'html':div.innerHTML,
                        'ancestor':r.commonAncestorContainer,
                        'pathAncestor':makeXPath(r.commonAncestorContainer),
                        'pathStart':makeXPath(findStart),
                        'pathEnd':makeXPath(findEnd),
                        'locate':r.commonAncestorContainer.outerHTML!=undefined?r.commonAncestorContainer.outerHTML:r.commonAncestorContainer.parentNode.outerHTML,
                    };
                    //

                }
                return _txt;
            } else {
                return null;
            }
        }
//			catch (e) {
//				return null;
//			}
    };

    $(window).keyup(function(e){
        if (e.ctrlKey && e.which==32) {
            console.clear();
            console.log(_getSelected());
            //document.getSelection().selectAllChildren($p)
        }});

    console.log('loaded');
</script>